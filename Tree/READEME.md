#树

###双亲表示法
>假设一组连续的空间存储数的结点，同时在每个结点中，附设一个指示器指示双亲结点到链表中的位置

	// 双亲表示法结构定义
	#define MAX_TREE_SIZE 100
	typedef int TElemType;
	typedef struct PTNode {
		TElemType data;5/18/2016 1:28:32 PM 
		int parent; //双亲位置
	}PTNode;
	typedef struct {
		PTNode ndoes[MAX_TREE_SIZE];
		int r,n;  // 根的位置和结点数
	}PTree;

这样的存储结构我们很容易的找到双亲结点，所用时间复杂度O(1)，知道parent为-1，如果要找结点的孩子是什么，需要遍历整个结构才行

###孩子表示法
>由于树种每个结点可能有多个子树，可以考虑多重链表，即每个结点有多个指针域，其中每个指针指向一个子树的根结点<br><br>
>具体办法，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针有组成一个线性表，采用顺序存储<br><br>
>需要设计两种结点结构，一个是孩子链表的孩子结点，child-->数据域，用来存储某个节点在表头数组中的下标，next是指针域，用来存储指向某节点下一个孩子结点指针。另一个是表头数组，data-->是数据域，存储某节点数据，firstchild-->是头指针域，存储该结点的孩子链表的头指针

	//定义结构	
	#define MAX_TREE_SIZE 100
	typedef struct CTNode {
		int child;
		struct CTNode *next;
	}*ChildPtr;
	typedef struct {
		TElemType data;
		ChildPtr firstchild;
	}CTBox;
	typedef struct {
		CTBox nodes[MAX_TREE_SIZE];
		int r, n;
	}CTree;

这种方法存在问题，就是知道某个节点的双亲是谁比较麻烦，需要遍历整棵树，所以在CTBox中添加一个parent属性就可以了，这种方法被称为双亲孩子表示法

###孩子兄弟表示法
>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的，因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 data-->数据域，firstchild-->指针域，存储该结点的第一个孩子结点的存储地址，rightsib-->指针域，存储该结点的右兄弟结点的存储地址

	// 孩子兄弟结构表示法
	typedef struct CSNode {
		TElemType data;
		struct CSNode *firstchild, *rightsib;
	}CSNode, *CSTree;


##二叉树
###二叉树特点：

1. 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。没有子树或者一棵子树也可以<br>
2. 左子树和右子树是有顺序的，次序不能颠倒<br>
3. 即使树中某节点只有一棵子树，也要区分他是左子树还是右子树

###特殊的二叉树
1.满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一个层上<br>
>特点：（1）叶子只能出现在最下一层 （2）非叶子结点的度一定是2 （3)在同样深度的二叉树，满二叉树结点个数最多

2.完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树编号为i的结点在二叉树中位置完全相同
>特点：（1）叶子结点只能出现在最下两层 （2）最下层的叶子一定集中在左部连续的位置 （3）倒数二层，若有叶子结点，一定都在右部连续位置 （4）如果结点度为1，则该结点只有左孩子 （5）同样的节点数的二叉树，完全二叉树深度最小

###二叉树的存储结构
####顺序存储
顺序存储：通过用一维数组存储二叉树的结点，并结点的存储位置，也就是数组下标体现结点之间的逻辑关系（一般只用于存完全二叉树）
